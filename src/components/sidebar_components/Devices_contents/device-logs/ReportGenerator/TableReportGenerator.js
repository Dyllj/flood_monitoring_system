// TableReportGenerator.js - Generate PDF report for table data
import jsPDF from 'jspdf';
import autoTable from 'jspdf-autotable';

export const generateTableReport = async (sensorId, filteredTableLogs, maxMetadata) => {
  const doc = new jsPDF('landscape'); // Use landscape for table
  const pageWidth = doc.internal.pageSize.width;
  let yPos = 20;

  // Header
  doc.setFontSize(18);
  doc.setFont(undefined, 'bold');
  doc.text('HISTORICAL DATA TABLE REPORT', pageWidth / 2, yPos, { align: 'center' });
  yPos += 10;

  doc.setFontSize(12);
  doc.setFont(undefined, 'normal');
  doc.text(`Sensor Location: ${sensorId}`, pageWidth / 2, yPos, { align: 'center' });
  yPos += 7;
  doc.text(`Report Generated: ${new Date().toLocaleString()}`, pageWidth / 2, yPos, { align: 'center' });
  yPos += 15;

  // Summary Statistics
  doc.setFontSize(11);
  doc.setFont(undefined, 'bold');
  doc.text('Summary Statistics:', 15, yPos);
  yPos += 7;

  const normalCount = filteredTableLogs.filter(log => log.distance <= maxMetadata.normalLevel).length;
  const elevatedCount = filteredTableLogs.filter(
    log => log.distance > maxMetadata.normalLevel && log.distance < maxMetadata.alertLevel
  ).length;
  const criticalCount = filteredTableLogs.filter(log => log.distance >= maxMetadata.alertLevel).length;

  doc.setFont(undefined, 'normal');
  doc.setFontSize(10);
  doc.text(`Total Readings: ${filteredTableLogs.length}`, 15, yPos);
  yPos += 5;
  doc.text(`Normal Readings: ${normalCount} (${((normalCount / filteredTableLogs.length) * 100).toFixed(1)}%)`, 15, yPos);
  yPos += 5;
  doc.text(`Elevated Readings: ${elevatedCount} (${((elevatedCount / filteredTableLogs.length) * 100).toFixed(1)}%)`, 15, yPos);
  yPos += 5;
  doc.text(`Critical Readings: ${criticalCount} (${((criticalCount / filteredTableLogs.length) * 100).toFixed(1)}%)`, 15, yPos);
  yPos += 15;

  // Table Data
  const tableData = filteredTableLogs
    .slice()
    .sort((a, b) => b.timestamp - a.timestamp)
    .map((log) => {
      let status = "Normal";
      if (log.distance >= maxMetadata.alertLevel) {
        status = "Critical";
      } else if (log.distance > maxMetadata.normalLevel && log.distance < maxMetadata.alertLevel) {
        status = "Elevated";
      }

      return [
        log.date,
        maxMetadata.maxHeight || 'N/A',
        maxMetadata.normalLevel || 'N/A',
        maxMetadata.alertLevel || 'N/A',
        log.distance,
        status
      ];
    });

  autoTable(doc, {
    startY: yPos,
    head: [['Date & Time', 'Max Height', 'Normal Level', 'Alert Level', 'Sensor Reading', 'Status']],
    body: tableData,
    theme: 'striped',
    headStyles: { fillColor: [41, 128, 185], fontSize: 9 },
    bodyStyles: { fontSize: 8 },
    columnStyles: {
      0: { cellWidth: 45 },
      1: { cellWidth: 25 },
      2: { cellWidth: 25 },
      3: { cellWidth: 25 },
      4: { cellWidth: 30 },
      5: { cellWidth: 25 }
    },
    didParseCell: (data) => {
      // Color code status column
      if (data.column.index === 5 && data.section === 'body') {
        const status = data.cell.raw;
        if (status === 'Critical') {
          data.cell.styles.textColor = [220, 53, 69];
          data.cell.styles.fontStyle = 'bold';
        } else if (status === 'Elevated') {
          data.cell.styles.textColor = [255, 193, 7];
          data.cell.styles.fontStyle = 'bold';
        } else if (status === 'Normal') {
          data.cell.styles.textColor = [40, 167, 69];
          data.cell.styles.fontStyle = 'bold';
        }
      }
    }
  });

  // Footer
  const finalY = doc.lastAutoTable.finalY + 15;
  doc.setFontSize(8);
  doc.text(`Generated by MDRRMO Monitoring System | ${new Date().toLocaleString()}`, 15, finalY);

  // Save
  const fileName = `Table_Report_${sensorId}_${new Date().toISOString().split('T')[0]}.pdf`;
  doc.save(fileName);
};